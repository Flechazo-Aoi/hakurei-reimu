---
title: 北京大学肖臻老师《区块链技术与应用》公开课笔记(二十四)：ETH反思
categories: 区块链
data: 2023-01-27  16:22:33
tags: 
- 区块链
- ETH
---

## Is samrt conract really smart?

智能合约真的智能吗？

答案是否定的。有人称其应该为自动合约，可以视为代码合同，因为他并没有涉及到人工智能。现实生活中的自动合约，比如ATM、自动贩卖机。就是你定好一个程序，这个东西只是简单的按照你编好的逻辑执行，并不智能，也就是Samrt conract is anything but smart

## Irrevocability is a double edged sword

不可篡改性是一把双刃剑。一方面来说，不可篡改性增加了合约的公信力，所有人必须按照合约定的规则执行，没有人能篡改这个规则；另一方面，如果合约中有漏洞，我们想修复漏洞，想升级都是很困难的。

比如上节提到的The DAO事件，传闻在被攻击的前几天就被告知了存在安全漏洞，但没来得及修复就被攻击了，这在一个中心化系统里是很难想象的，软件有漏洞及时发布一个补丁不就好了，但是这是去中心化的系统，想要修复是很困难的，这和我们日常生活的感觉相违背。所以不能用常识性的认知来玩区块链

与之相关的问题是，如果一个智能合约发布到区块链中，无法阻止对它的调用。

## Nothing is irrevocable

没有什么是绝对不可修改的，代码是死的，人是活的。我们你一个交易发布到区块链上，经过多少多少个区块就不可修改了，这只是概率上的不可修改，恶意节点足够强大，发动分叉攻击，那还是能修改你的交易。包括上节开发团队对智能合约的修改，都证明了不可篡改不是绝对的

现实中宪法都能修改，还有什么是不能修改的呢，美国发布过很多宪法修正案，为的就是修改宪法不合理的地方，但是有意思的是有一个修正案被推翻过，就是第18修正案的禁酒令，在第21修正案被驳回了

## Is solidity the right programming language?

> Solidity语言设计上是否有问题？

我们提到转账是隐式调用你的fallback()函数，而fallback()函数又可以定义成调用别的函数，这是很反直觉的。所以有人干脆提出用函数式编程语言，函数式编程语言比较安全，不容易出现系统漏洞，而且从长远上看，要实现的是对智能合约功能的理论上的功能的正确性。

实际上，我们确实可以说，从语言设计的角度，Solidity语言还有很多值得改进的地方，但如果说我们就应该用函数式编程语言，我们就应该用formal proof的方法证明程序的正确性，这还有待商榷

> 语言设计上的另一个反思是：编写智能合约的编程语言应该有什么样的表达能力

我们前面提到过，比特币的编程语言是很简单的，而以太坊的编程语言是图灵完备的(凡是计算机程序能够完成的任务，这两种语言都可以把他实现出来)。但是图灵完备的表达能力是不是一个好事情，自从出现这些智能合约之后，有些人认为应该采用一些比较适中的语言编写智能合约，既不要像比特币脚本那么简单，也不要像以太坊用的Solidity一样表达能力是图灵完备的，也就是说这种编程语言能实现智能合约的功能，又不容易出现安全漏洞。

问题是，很难设计这样一款语言，因为你很难事先把所有可能出现的情况都预料到。那怎么办呢，我们想想现实生活中，也有合同，合同是通过表达能力很强的自然语言编写的，从理论上说也可能出现各种安全漏洞。那是不是我们为写合同设置一种专用语言，实际上不是的，实际上是有一些模板，在模板的基础上编写。其实就是加入一些限制和规范。

上面说了这么多问题，但我们也不要对智能合约，对区块链失去信心，因为它们仍处在早期，再过一段时间，它们会变得更加成熟。

## 开源

去中心化的好处，有人认为是透明性好，中心化的系统很多是不开源的，去中心化的系统大多数是开源的，因为你要所有的节点都执行同样的操作才能让系统达成共识。

> 那么开源有什么好处呢？

开源可以增加合约的公信力，接受群众的监督，因为如果区块链不开源，那么没人知道你里面写的什么东西，也就不敢挖矿。

> 开源就代表安全么？因为开源软件谁都可以看他的源代码，世界人民都能监督。

并不是的。事实上有很多开源软件都会出现开源漏洞，那么既然所有人都能看源代码，那么他应该很安全才是，为什么还会出现各种各样的问题呢？ 有人称这种现象为many eyeball fallacy(多眼球谬论)，就是实际上真正有时间精力看源码的人是少之又少的，看源码的人能发现漏洞的人也是少之又少的。

所以不要认为开源软件比非开源软件安全，也不要认为很多人使用的软件一定安全

## 去中心化

区块链技术的追随者，一般都是去中心化理念的拥护者，这些人对现实生活中的中心化系统不满意，所以在区块链的世界里寻找去中心化的可能性

**what does decentralization means？**

我们之前提到的硬分叉解决问题时，开发团队发起了投票，最终是大部人同意硬分叉，但是开发团队并没有办法强制大家接受投票结果，最终硬分叉能成功是因为，系统中大多数人升级了软件，用行动支持了硬分叉，即使是这样，还有少部分矿工不支持硬分叉，留在旧链 上挖矿。

所以**去中心化不是全自动化**，让机器决定一切，不能有人为干预，去中心化并不是说已经制定的规则就不能修改，而是对**规则的修改要用去中心化的方式来完成**

## 分叉

我们一般认为分叉是一件坏事，但是**分叉恰恰是去中心化**的体现，在一个中心化的系统里是不允许有分叉的，你可以放弃，但你不能分叉

> 这里有一个故事，Vitalik Buterin，以太币的创始人为什么要设计以太币。因为他小时候爱玩魔兽世界，然后暴雪在2010年削弱了术士这个职业，让他意识到中心化服务可能带来的恐惧，所以才想创建一个去中心化的平台，用户不满意就分叉

所以存在分叉选项恰恰是民主的一种体现

## decentralized  ≠  distributed

去中心化不等于分布式。

去中心化的系统一定是分布式的，因为你运行在一台计算机上怎么能叫去中心化；而分布式不一定是去中心化的，运行在成千上万台计算机上的系统不一定是去中心化系统。

比特币和以太坊都是交易驱动的状态机(state machine)，特点是让系统中几千台机器重复做同样的操作，付出很大的代价来维护状态的一致性。

> 但这并不是分布式系统常用的工作模式。常用的分布式系统是让每台机器做不同的事情，然后把各台机器的工作结果汇总起来，得到最后的结果，这样做的目的是为了比单机速度快。也就是一台计算机干一个活花10天，那么用一个10台计算机的分布集群花1天就能干完。实际上，线性加速比很难达到，因为涉及到任务切分、任务通讯等，所以实际上10台相当于1台的6、7倍

状态机的目的不是为了比一台计算机快，而是为了容错。状态机最早的应用场景是mission critical aaplication(关键任务应用)，比如空中交通管制ATC(Air Traffic Control)、证券交易所(Stock Exchange)、(往返于地球和太空站之间运载人和物资的)航天飞机(space shuttle)，这个应用必须无间断地对外提供服务，哪怕宕机一分钟，都会造成很大的影响，所以由好几台计算机同时执行同样的操作来确保系统的无间断执行。这样的代价是系统的执行效率很低，好几台机器合在一起比一台机器还要慢(因为要存储状态)，并且机器越多，效率越低。所以传统的使用状态机的场景机器数目都是比较少的，大多是个位数。像比特币、以太坊这种上千台机器的状态机是很少见的。

说这些的目的是不要认为比特币或者以太坊这种分布式系统的组织形式是常态，他其实是少数，不要以太坊中的EVM平台当作大规模计算或者大规模存储的服务，这样做不仅速度很慢，而且还很贵(耗费很多汽油费)，智能合约是编写控制逻辑的，只有那些互不信任的实体之间建立共识的操作才需要写在智能合约里