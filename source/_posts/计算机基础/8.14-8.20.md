---
title: 8.14-8.20
categories: 计算机基础
tags:
- 随笔
- 培训
---

## SonarQube

### 简介

- SonarQube是一个开源的静态代码分析工具，根据不同语言的规则，对代码进行扫描，扫描出潜在的问题并提供修改方案。
- SonarQube除了支持自有的规则外，还可以通过插件的方式，支持CheckStyle、FindBugs、PMD等其他代码质量分析工具的规则
- 除了搭建SonarQube服务器，还可以在IDEA编辑器，安装SonarLint插件对代码进行扫描

### 管理问题

可以点进去问题查看单个问题的详情，点击**为何是问题？**查看修改建议

对问题可以标记为：

- 不会修复：代表检测出的问题不需要解决
- 误判：代表系统误判

标记上述两种标记后，下次扫描就会自动略过。

### 项目详情

#### 质量阈

只有配置了管理质量阈的用户，才可以编辑质量阈。

可以自定义编辑质量阈的条件，比如Bugs > 0 & 漏洞 > 0...

满足任一条件则质量阈状态为错误，否则为正常

#### 问题



#### 安全热点

不一定是问题，需要审核确认是否为安全漏洞

#### 指标

## Yapi

### 前后端分离的痛点：

- 文档缺失，输入输出没有预期，或与预期不符。
- 文档老旧，不够全面，如文档中的接口已失效，有用的接口不放在文档里。
- 前端开发依赖于后端接口数据，需要与后端接口联调才能获得数据展示，拖慢了开发进度。
- 难以使用常规文本文档工具，对项目中所用到的接口进行管理。

接口问题：

1. 接口的字段更新了
2. 接口的路由更新了
3. 接口返回了未预期的值
4. 接口返回由于某种原因被删除了

所以要使用接口文档管理工具-YApi

### 接口基本管理

#### 请求参数

- 请求Body：http 请求 body 部分。如果http请求方式是 post, put 等请求方式时会有req_body 部分。req_body_type有4种，分别是 form, json, file 和 raw 。
- Query参数：接口 url 的查询字符串参数，可以通过拖动来交换参数位置。
- Headers: http 请求头字段。

#### 返回数据

两种形式：JSON和RAW

### 导入导出

#### 导入：

1. 普通模式(normal)：不导入已存在的接口；
2. 智能合并(good)：已存在的接口，将合并返回数据的response，适用于导入了 swagger 数据，保留对数据结构的改动；
3. 完全覆盖(mergin)：不保留旧数据，完全使用新数据，适用于接口定义完全交给后端定义。

默认导入方式为normal

#### 导出：

项目 -> 数据管理，选择需要导出的数据方式，一共有三种导出方式，html,markdown,json。然后点击导出按钮，将会下载数据文件。

### 自动化测试

通过添加测试集合，完善测试用例，接口的入参和对`RESPONSE`断言，即可实现对接口的自动化测试

### 二次开发注意事项：

1. 将package.json中 “eslint-plugin-react” 的版本限制为7.1.0版本
2. 安装cross env 并修改脚本中 `NODE_ENV=` 为 `cross-env NODE_ENV=`
3. 在ykit.config.js中针对`swagger-client` 添加对应`babel-loader`。
4. /server中后端程序修改后重新启动即可生效。

## Quartz、XXL-JOB

### 定时任务

- 定时任务：在规定的时间触发执行某个任务。
- 定时任务框架(Java)：使用Java语言编写的定时任务工具包（函数的集合）。
- 作用：让程序在指定的时间触发执行某个动作。

### Quartz

Quartz是一个开源的任务调度框架，用于在Java应用程序中实现作业调度。

#### **功能特点：**

- **方便**：完全由Java编写，对Java工程师使用友好。
- **灵活的任务调度**：可以按照指定的时间表执行任务，也可以根据配置的规则，进行重复执行任务。
- **支持多种类型的触发器**：简单触发器、Cron触发器、日历触发器。
- **可靠性和持久性**：支持作业和触发器配置持久化到数据库中。
- **分布式和集群支持**：支持分布式和集群模式，解决高可用问题。

##### **核心组件：**

作业(Job)：需要执行的任务

触发器(Trigger)：定义作业何时执行的规则

- 简单触发器(SimpleTrigger)：简单触发器允许在指定的时间间隔内重复执行作业。
- Cron触发器(CronTrigger)：允许使用Cron表达式定义更复杂的执行规则
- 日历触发器（CalendarTrigger）：可以排除指定的日期或时间段，控制作业的执行

调度器(Scheduler)：管理作业和触发器的注册和执行，调度器可以启动、暂停、停止作业的运行，并负责将作业分配给合适的执行线程。

### XXL-JOB

XXL-JOB是一个**分布式**任务调度平台。

##### **主要特性**

- **可视化管理页面**，可配置、管理、监控定时任务。
- **调度中心HA**，调度组件支持集群部署，可保证调度中心HA
- **分布式任务调度**，通过分片广播能力，支持**大数据量任务的分布式调度**执行
- **丰富的路由策略**，执行器集群部署时提供丰富的路由策略

##### **核心组件：**

调度中心HA：

```
负责管理调度信息，按照调度配置发出调度请求，自身不承担业务代码。调度系统与任务解耦，
提高了系统可用性和稳定性，同时调度系统性能不再受限于任务模块。
```

执行器：负责接收调度请求并执行任务逻辑，执行器专注于任务的执行。

### CRON表达式

Cron(Command Run On)表达式是一种用于指定任务在某个时间点或周期性执行的字符串表达式。

## 数据库运维

### 定义

数据库运维服务是指用户数据库开展的软件安装、配置优化、备份策略选择及实施、数据恢复、数据迁移、故障排除、预防性巡检等一系列服务。

## 日志框架与应用

### 日志框架与日志门面：

- 日志框架
  - JUL(Java Util Log )是Java官方提供的日志库，使用的并不是非常广泛，性能较低。
  - Log4j是一个基于Java的日志记录工具。
  - Logback与Log4j是同一作者作品，完美继承了Log4j的优点并补足了Log4j的不足。
  - Log4j2是apache开发的一款Log4j的升级产品,并且不兼容Log4j
- 日志门面：主要有JCL 、Slf4j

```
是门面模式的一个应用。可以抽象的理解为java的接口，日志框架可以理解为接口的具体实现。
日志门面兼容了多种日志框架，使得应用和框架的耦合性大大降低。
```

### Logback介绍：

是SpringBoot内置的日志处理框架。

#### 日志级别

等级从低到高分别是TRACE < DEBUG < INFO < WARN < ERROR，高级别日志会覆盖低级别日志（配置INFO级别的日志，那么TRACE和DEBUG级别的日志不会显示）

- **Trace:**是追踪，就是程序推进一下，你就可以写个trace输出，所以trace应该会特别多
- **Debug:**指出细粒度信息事件对调试应用程序是非常有帮助的
- **Info**:消息在粗粒度级别上突出强调应用程序的运行过程
- **Warn**:输出警告及warn以下级别的日志
- **Error**:输出错误信息日志

#### 配置文件

##### 命名：

Spring Boot官方推荐优先使用带有`-spring`的文件名作为你的日志配置（如使用`logback-spring.xml`，而不是`logback.xml`，两者都存在会默认读取前者）

##### **configuration**

- **scan :** 当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。
- **scanPeriod :** 设置监测配置文件是否有修改的时间间隔，默认单位是毫秒。只有当scan为true时，此属性才生效。默认的时间间隔为1分钟。
- **debug :** 当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。

```xml
<configuration scan = "true" scanPeriod="10 seconds" debug="false">
</configuration>
```

**property**：自定义变量，使用时格式为`${LOG_PATH}`

```xml
<property name="LOG_PATH" value="./logs" />
```

##### **appender**

appender是 `<configuration> `的子节点，是负责写日志的组件,该标签负责以适当的格式将日志记录事件输出到适当的输出设备。

```xml
<!--name: appender名称; class: appender类的全限定名 -->
<appender name="..." class="...">
</appender>
```

常用appender类型：

- **RollingFileAppender:** 滚动记录地把日志输出到文件, 也就是可以支持日志文件按文件大小拆分,或者按日期拆分
- **ConsoleAppender:** 把日志打印到控制台
- **FileAppender:** 把日志输出到文件
- 还有一些不常用的appender类型：`ServerSocketAppender` -网络传输日志事件、`SSLServerSocketAppender`-增加SSL加密验证、`SMTPAppender`-将日志进行邮件发送

##### **logger**

用来设置某一个包或者具体的某一个类的日志打印级别、以及指定`<appender>`

```xml
<!--name: 用于指定受此logger约束的一个包或类
	level: 日志级别
	additivity: true/false，它是子Logger 是否继承父Logger 的输出源（appender） 的标志位。
	appender-ref: 是上面提到的appender类型定义的name的引用
 		-->

<logger name="com.topscomm" level="INFO" additivity="false">
	<appender-ref ref="stdout" />
    <appender-ref ref="server" />
</logger>
```

```
additivity的属性为true/false，它是子Logger 是否继承父Logger 的输出源（appender） 的标志位。具体说，
默认情况下子Logger会继承父Logger的appender，也就是说子Logger会在父Logger的appender里输出。
若是additivity设为false，则子Logger只会在自己的appender里输出，而不会在父Logger的appender里输出。
```

##### **root**

 根元素，只有一个level属性,也是<logger>元素，但是它是根logger。`<root> `可以包含零个或多个` <appender-ref>` 元素

```xml
<root level="INFO">
	<appender-ref ref="stdout" />
</root>
```

### Logback与Log4j

上面说过Logback完美继承了Log4j，所以Logback基础使用方面与Log4j相同，如日志等级、三大组件等等

Logback本质上是一个优化后的Log4j，但相比于Log4j有太多的有点，官方列举Logback具有以下几点优势：

- 更快的实施：Logback重写了Log4j内部实现，在关键路径提升了十倍速度，减少了内存损耗。
- 更广泛的测试：Logback比Log4j进行了更长时间、更高级别的测试。
- 与SLF4J的完美结合
- 更广泛的文档：Logback具有更详细并且不断更新的文档。
- Logback从0.9.22版本开始同时支持XML与Groovy语法的配置文件
- Logback可以自动扫描并加载修改后的配置文件，并且不启用新的线程资源
- Logback通过对于maxHistory属性的设置可以自动删除旧的日志文件
- Logback的RollingFileAppender可以异步的对旧的日志文档进行压缩

## 中间件

